#!/usr/bin/env ruby

require 'intesisbox'
require 'mqtt'

class MQTTBridge
  def initialize(mqtt_uri)
    @base_topic = "homie/intesisbox"
    @mqtt = MQTT::Client.new(mqtt_uri)
    @mqtt.set_will("#{@base_topic}/$state", "lost", true)
    @mqtt.connect
    @attributes = {}
    @wmps = {}
    @discovery = 300
    @units = :C

    publish_basic_attributes
    publish("$nodes", "bridge")

    start_discovery_thread

    @mqtt.get do |topic, value|
      puts "got #{value.inspect} at #{topic}"
      topic = topic[(@base_topic.length + 1)..-1]

      if topic =~ %r{^bridge/discovery(/set)?$} && value =~ /^\d+$/
        old_discovery = @discovery
        discovery = value.to_i
        next if discovery > 86400
        @discovery = discovery
        if $1.nil?
          unsubscribe("bridge/discovery")
        end

        publish("bridge/discovery", @discovery)
        if @discovery < old_discovery || old_discovery == 0
          @discovery_thread.kill
          start_discovery_thread
        end
        next
      elsif topic =~ %r{^bridge/units(/set)?$} && %w{C F}.include?(value)
        old_units = @units
        @units = value.to_sym
        if $1.nil?
          unsubscribe("bridge/units")
        end

        if old_units != @units
          publish("bridge/units", @units)
          next if @wmps.empty?
          publish("$state", "init")

  
          @wmps.each do |(mac, wmp)|
            publish_attribute("#{mac}/setptemp", convert_units(wmp.setptemp))
            publish("#{mac}/setptemp/$unit", "ยบ#{@units}")
            publish("#{mac}/setptemp/$format",
              wmp.limits[:setptemp].map { |lim| convert_units(lim) }.join(":"))
            if wmp.ambtemp
              publish_attribute("#{mac}/ambtemp", convert_units(wmp.ambtemp))
              publish("#{mac}/ambtemp/$unit", "ยบ#{@units}")
            end
          end
          publish("$state", "ready")
        end
        next
      end

      %r{([0-9A-F]+)/(mode|fansp|vaneud|vanelr|onoff|setptemp)/set$} =~ topic
      wmp = @wmps[$1]
      next unless wmp
      function = $2
      case function
      when 'onoff'
        wmp.onoff = value == 'true'
      when 'setptemp'
        wmp.setptemp = value.to_f
      else
        wmp.send("#{function}=", value)
      end
    end
  end

  def start_discovery_thread
    @discovery_thread = Thread.new do
      discover
      loop do
        break if @discovery == 0
        sleep(@discovery)
        discover
      end
    end
  end

  def discover
    wmp_details = IntesisBox::Discovery.discover

    # force a reconnect to WMPs that have moved
    wmp_details.each do |(mac, details)|
      known_wmp = @wmps[mac]
      if known_wmp && known_wmp.ip != details[:ip]
        @wmps.delete(mac)
      end
    end

    known_macs = @wmps.keys.to_set
    wmp_details.reject! { |(mac, details)| known_macs.include?(mac)} 

    return if wmp_details.empty?

    publish("$state", "init")
    wmps = wmp_details.map { |(mac, details)| IntesisBox::Client.new(details[:ip])}

    wmps.each do |wmp|
      loop do
        break if wmp.mac
        unless wmp.poll(1)
          puts "unable to talk to #{wmp.mac}"
          break
        end
      end
    end
    wmps.delete_if { |wmp| !wmp.mac }

    wmps.each { |wmp| publish_wmp(wmp) }

    wmps.each do |wmp|
      Thread.new do
        loop do
          next wmp.ping unless wmp.poll
          publish_attribute("#{wmp.mac}/onoff", wmp.onoff)
          publish_attribute("#{wmp.mac}/mode", wmp.mode) if wmp.limits[:mode]&.length.to_i > 0
          publish_attribute("#{wmp.mac}/fansp", wmp.fansp) if wmp.limits[:fansp]&.length.to_i > 0
          publish_attribute("#{wmp.mac}/vaneud", wmp.vaneud) if wmp.limits[:vaneud]&.length.to_i > 0
          publish_attribute("#{wmp.mac}/vanelr", wmp.vanelr) if wmp.limits[:vanelr]&.length.to_i > 0
          publish_attribute("#{wmp.mac}/setptemp", convert_units(wmp.setptemp))
          publish_attribute("#{wmp.mac}/ambtemp", convert_units(wmp.ambtemp)) if wmp.ambtemp
          publish_attribute("#{wmp.mac}/errstatus", wmp.errstatus)
          publish_attribute("#{wmp.mac}/errcode", wmp.errcode)
        end
      end
    end

    wmps.each { |wmp| @wmps[wmp.mac] = wmp }
    publish("$nodes", (["bridge"] + @wmps.keys.sort).join(","))
    publish("$state", "ready")
  end

  def publish(topic, value)
    @mqtt.publish("#{@base_topic}/#{topic}", value, true, 1)
  end

  def publish_attribute(attr, value)
    if !@attributes.key?(attr) || @attributes[attr] != value
      publish(attr, value.to_s)
      @attributes[attr] = value
    end
  end

  def subscribe(topic)
    @mqtt.subscribe("#{@base_topic}/#{topic}")
  end

  def unsubscribe(topic)
    @mqtt.unsubscribe("#{@base_topic}/#{topic}")
  end

  def publish_basic_attributes
    publish("$homie", "v4.0.0")
    publish("$name", "IntesisBox")
    publish("$state", "init")

    publish("bridge/$name", "Bridge")
    publish("bridge/$type", "Bridge")
    publish("bridge/$properties", "discover")

    publish("bridge/discovery/$name", "Auto-Discovery Interval")
    publish("bridge/discovery/$datatype", "integer")
    publish("bridge/discovery/$settable", "true")
    publish("bridge/discovery/$format", "0:86400")
    publish("bridge/discovery/$unit", "s")
    publish("bridge/discovery", @discovery)
    subscribe("bridge/discovery")
    subscribe("bridge/discovery/set")

    publish("bridge/units/$name", "Units")
    publish("bridge/units/$datatype", "enum")
    publish("bridge/units/$settable", "true")
    publish("bridge/units/$format", "C,F")
    publish("bridge/units", @units)
    subscribe("bridge/units")
    subscribe("bridge/units/set")
  end

  def publish_wmp(wmp)
    publish("#{wmp.mac}/$name", wmp.devicename)
    publish("#{wmp.mac}/$type", wmp.model)
    properties = []
    
    properties << 'onoff'
    publish("#{wmp.mac}/onoff/$name", "AC unit On or Off")
    publish("#{wmp.mac}/onoff/$datatype", "boolean")
    publish("#{wmp.mac}/onoff/$settable", "true")
    subscribe("#{wmp.mac}/onoff/set")

    if wmp.limits[:mode]&.length.to_i > 0
      properties << 'mode'
      publish("#{wmp.mac}/mode/$name", "Mode (heat, cool, fan, dry or auto)")
      publish("#{wmp.mac}/mode/$datatype", "enum")
      publish("#{wmp.mac}/mode/$format", wmp.limits[:mode].join(","))
      publish("#{wmp.mac}/mode/$settable", "true")
      subscribe("#{wmp.mac}/mode/set")
    end

    if wmp.limits[:fansp]&.length.to_i > 0
      properties << 'fansp'
      publish("#{wmp.mac}/fansp/$name", "Fan speed")
      publish("#{wmp.mac}/fansp/$datatype", "enum")
      publish("#{wmp.mac}/fansp/$format", wmp.limits[:fansp].join(","))
      publish("#{wmp.mac}/fansp/$settable", "true")
      subscribe("#{wmp.mac}/fansp/set")
    end

    if wmp.limits[:vaneud]&.length.to_i > 0
      properties << 'vaneud'
      publish("#{wmp.mac}/vaneud/$name", "Up/Down vane position")
      publish("#{wmp.mac}/vaneud/$datatype", "enum")
      publish("#{wmp.mac}/vaneud/$format", wmp.limits[:vaneud].join(","))
      publish("#{wmp.mac}/vaneud/$settable", "true")
      subscribe("#{wmp.mac}/vaneud/set")
    end

    if wmp.limits[:vanelr]&.length.to_i > 0
      properties << 'vanelr'
      publish("#{wmp.mac}/vanelr/$name", "Left/Right vane position")
      publish("#{wmp.mac}/vanelr/$datatype", "enum")
      publish("#{wmp.mac}/vanelr/$format", wmp.limits[:vanelr].join(","))
      publish("#{wmp.mac}/vanelr/$settable", "true")
      subscribe("#{wmp.mac}/vanelr/set")
    end

    properties << 'setptemp'
    publish("#{wmp.mac}/setptemp/$name", "Set point temperature")
    publish("#{wmp.mac}/setptemp/$datatype", "float")
    publish("#{wmp.mac}/setptemp/$format",
      wmp.limits[:setptemp].map { |lim| convert_units(lim) }.join(":"))
    publish("#{wmp.mac}/setptemp/$unit", "ยบ#{@units}")
    publish("#{wmp.mac}/setptemp/$settable", "true")
    subscribe("#{wmp.mac}/setptemp/set")

    if wmp.ambtemp
      properties << 'ambtemp'
      publish("#{wmp.mac}/ambtemp/$name", "Ambient temperature")
      publish("#{wmp.mac}/ambtemp/$datatype", "float")
      publish("#{wmp.mac}/ambtemp/$unit", "ยบ#{@units}")
    end

    properties << 'errstatus'
    publish("#{wmp.mac}/errstatus/$name", "Shows if any error occurs")
    publish("#{wmp.mac}/errstatus/$datatype", "string")

    properties << 'errcode'
    publish("#{wmp.mac}/errcode/$name", "Error code")
    publish("#{wmp.mac}/errcode/$datatype", "integer")

    publish("#{wmp.mac}/$properties", properties.join(","))
  end

  def convert_units(value)
    return value if @units == :C
    value * 9/5.0 + 32
  end
end

mqtt_uri = ARGV[0]
MQTTBridge.new(mqtt_uri)
